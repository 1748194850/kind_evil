# 项目执行流程详解 - 从零开始理解

> 📖 **适合人群**：没有Unity和C#基础的初学者  
> 🎯 **目标**：让你完全理解游戏是如何运行的

---

## 📚 目录

1. [Unity的基本概念](#1-unity的基本概念)
2. [游戏启动流程](#2-游戏启动流程)
3. [场景加载过程](#3-场景加载过程)
4. [管理器初始化顺序](#4-管理器初始化顺序)
5. [游戏循环（每一帧发生了什么）](#5-游戏循环每一帧发生了什么)
6. [玩家输入处理流程](#6-玩家输入处理流程)
7. [玩家移动和跳跃流程](#7-玩家移动和跳跃流程)
8. [完整流程图](#8-完整流程图)

---

## 1. Unity的基本概念

### 1.1 什么是场景（Scene）？

**简单理解**：场景就像游戏的一个"房间"。你可以在场景里放置：
- 玩家角色
- 地面、墙壁
- 敌人
- 摄像机
- 各种管理器

**类比**：就像搭积木，场景就是你的积木盒子，里面装着所有积木。

### 1.2 什么是GameObject（游戏对象）？

**简单理解**：场景里的任何东西都是一个GameObject，比如：
- 玩家是一个GameObject
- 地面是一个GameObject
- 摄像机是一个GameObject

**类比**：GameObject就像积木，你可以给它添加各种"功能"（组件）。

### 1.3 什么是Component（组件）？

**简单理解**：组件是给GameObject添加功能的"插件"。比如：
- `Rigidbody2D`：让物体受物理影响（会掉下来）
- `Collider2D`：让物体有碰撞（不会穿墙）
- `PlayerController`：让物体能移动和跳跃

**类比**：组件就像给积木贴的标签，告诉它"你会飞"、"你会发光"。

### 1.4 Unity的生命周期方法

Unity会按固定顺序调用这些方法，就像"剧本"：

| 方法名 | 什么时候调用 | 简单理解 |
|--------|------------|---------|
| `Awake()` | 对象创建时，最早 | "我出生了！" |
| `Start()` | 第一帧之前，所有Awake之后 | "准备开始！" |
| `Update()` | 每一帧都调用（每秒60次左右） | "我在运行！" |
| `OnDestroy()` | 对象被删除时 | "我要消失了！" |

**类比**：就像人的一生：
- `Awake()` = 出生
- `Start()` = 开始上学
- `Update()` = 每天的生活
- `OnDestroy()` = 死亡

---

## 2. 游戏启动流程

### 2.1 当你点击"播放"按钮时

```
1. Unity加载场景文件（.scene）
   ↓
2. 创建场景中的所有GameObject
   ↓
3. 给每个GameObject添加组件（脚本）
   ↓
4. 按顺序调用所有组件的 Awake()
   ↓
5. 按顺序调用所有组件的 Start()
   ↓
6. 开始游戏循环（每帧调用 Update()）
```

### 2.2 详细步骤说明

#### 步骤1：加载场景
- Unity读取场景文件（比如 `test_sence.scene`）
- 知道要创建哪些对象，放在哪里

#### 步骤2：创建对象
- 根据场景文件，创建所有GameObject
- 比如：创建"Player"、"Ground"、"Camera"

#### 步骤3：添加组件
- 给每个GameObject添加它需要的组件
- 比如：给Player添加`Rigidbody2D`、`Collider2D`、`PlayerController`

#### 步骤4：Awake阶段
- 所有对象的`Awake()`方法被调用
- 这是"初始化"阶段，准备各种设置

#### 步骤5：Start阶段
- 所有对象的`Start()`方法被调用
- 这是"准备开始"阶段，建立连接

#### 步骤6：游戏循环
- 每帧（约1/60秒）调用所有`Update()`方法
- 游戏开始运行！

---

## 3. 场景加载过程

### 3.1 场景文件里有什么？

场景文件（.scene）就像一张"清单"，告诉Unity：

```
场景清单：
├── 创建这些对象：
│   ├── Main Camera（摄像机）
│   ├── Player（玩家）
│   │   └── 添加组件：PlayerController, Rigidbody2D, Collider2D
│   ├── Ground（地面）
│   │   └── 添加组件：Collider2D
│   └── Managers（管理器组）
│       ├── GameManager
│       ├── InputManager
│       ├── EventManager
│       └── ...
└── 设置这些参数：
    ├── Player的位置：(0, 0, 0)
    ├── Player的移动速度：8
    └── ...
```

### 3.2 场景加载的详细流程

```
Unity读取场景文件
    ↓
创建所有GameObject（但还没激活）
    ↓
给每个GameObject添加组件
    ↓
设置每个组件的参数（从场景文件读取）
    ↓
激活所有GameObject
    ↓
调用所有组件的 Awake()
    ↓
调用所有组件的 Start()
    ↓
开始游戏循环
```

---

## 4. 管理器初始化顺序

### 4.1 什么是Singleton（单例）？

**简单理解**：Singleton确保整个游戏里只有一个"管理器"。

**为什么需要**：
- 如果游戏里有两个InputManager，就不知道听哪个的
- Singleton保证只有一个，所有人都找它

**类比**：就像学校只有一个校长，所有人都找校长。

### 4.2 管理器的初始化顺序

#### 第一步：创建GameObject
```
场景加载时，Unity创建：
- GameManager（空对象）
- InputManager（空对象）
- EventManager（空对象）
- ...
```

#### 第二步：添加组件
```
给每个对象添加对应的脚本：
- GameManager对象 → 添加 GameManager 脚本
- InputManager对象 → 添加 InputManager 脚本
- ...
```

#### 第三步：Awake阶段（初始化）

**GameManager的Awake()**：
```csharp
protected override void Awake()
{
    base.Awake();  // 调用父类（Singleton）的Awake
    InitializeGame();  // 初始化游戏
}
```

**Singleton的Awake()做了什么**：
```csharp
protected virtual void Awake()
{
    if (instance == null)  // 如果还没有实例
    {
        instance = this;  // 我就是唯一的实例！
        DontDestroyOnLoad(gameObject);  // 切换场景时不要删除我
    }
    else  // 如果已经有实例了
    {
        Destroy(gameObject);  // 删除这个多余的
    }
}
```

**执行顺序**：
```
1. GameManager.Awake()
   ├── Singleton.Awake()（检查是否唯一）
   └── InitializeGame()（初始化游戏）

2. InputManager.Awake()
   └── Singleton.Awake()（检查是否唯一）

3. EventManager.Awake()
   └── Singleton.Awake()（检查是否唯一）

4. PlayerController.Awake()（如果有）
   └── 获取Rigidbody2D组件
```

#### 第四步：Start阶段（建立连接）

**PlayerController的Start()**：
```csharp
private void Start()
{
    // 获取组件
    rb = GetComponent<Rigidbody2D>();
    
    // 订阅输入事件（告诉InputManager：跳跃时叫我！）
    InputManager.Instance.OnJumpPressed += Jump;
}
```

**执行顺序**：
```
1. GameManager.Start()（如果有）
2. InputManager.Start()（如果有）
3. PlayerController.Start()
   └── 订阅跳跃事件：InputManager.Instance.OnJumpPressed += Jump
```

---

## 5. 游戏循环（每一帧发生了什么）

### 5.1 什么是帧（Frame）？

**简单理解**：
- 游戏画面每秒更新60次（60 FPS）
- 每次更新就是一"帧"
- 每帧都会调用`Update()`方法

**类比**：就像翻书，每秒翻60页，每页就是一幅画面。

### 5.2 一帧的完整流程

```
第N帧开始
    ↓
1. InputManager.Update()
   └── 检查键盘输入（WASD、空格等）
   └── 更新 moveInput、aimInput
   └── 如果按下跳跃键 → 触发 OnJumpPressed 事件
    ↓
2. PlayerController.Update()
   └── CheckGrounded()（检查是否在地面）
   └── 获取移动输入：InputManager.Instance.GetMoveInput()
   └── 更新速度：rb.velocity = new Vector2(moveInput.x * moveSpeed, rb.velocity.y)
   └── 翻转精灵（根据移动方向）
    ↓
3. Unity物理系统更新
   └── 根据速度移动所有Rigidbody2D
   └── 检测碰撞
    ↓
4. Unity渲染系统更新
   └── 绘制所有可见对象
    ↓
第N帧结束
    ↓
等待下一帧（约0.016秒后）
    ↓
第N+1帧开始（重复上述过程）
```

### 5.3 详细说明

#### InputManager.Update()
```csharp
private void Update()
{
    HandleInput();  // 处理输入
}

private void HandleInput()
{
    // 1. 获取移动输入（WASD或方向键）
    moveInput = new Vector2(
        GetAxisRawSafe("Horizontal"),  // 左右：-1到1
        GetAxisRawSafe("Vertical")     // 上下：-1到1
    );
    
    // 2. 检查按钮输入
    if (GetButtonDownSafe("Jump"))  // 如果按下空格
    {
        OnJumpPressed?.Invoke();  // 触发跳跃事件（通知所有订阅者）
    }
}
```

#### PlayerController.Update()
```csharp
private void Update()
{
    // 1. 检查是否在地面
    CheckGrounded();
    
    // 2. 获取移动输入
    Vector2 moveInput = InputManager.Instance.GetMoveInput();
    
    // 3. 更新速度（只更新X，Y由物理系统控制）
    rb.velocity = new Vector2(moveInput.x * moveSpeed, rb.velocity.y);
    
    // 4. 翻转精灵（向左移动时镜像）
    if (moveInput.x > 0.1f)
        spriteRenderer.flipX = false;  // 向右
    else if (moveInput.x < -0.1f)
        spriteRenderer.flipX = true;   // 向左
}
```

---

## 6. 玩家输入处理流程

### 6.1 完整的输入流程

```
玩家按下键盘（比如按"空格"）
    ↓
Unity的Input系统检测到按键
    ↓
InputManager.Update()被调用
    ↓
InputManager检查：GetButtonDownSafe("Jump")
    ↓
如果按下 → 触发事件：OnJumpPressed?.Invoke()
    ↓
所有订阅了这个事件的对象收到通知
    ↓
PlayerController的Jump()方法被调用
    ↓
执行跳跃逻辑
```

### 6.2 事件系统（Event System）

**什么是事件？**

**简单理解**：事件就像"广播"。
- InputManager说："有人按了跳跃键！"
- 所有"订阅"了这个广播的对象都会收到通知
- PlayerController听到后，执行跳跃

**类比**：就像学校广播"下课了！"，所有学生都听到，然后开始行动。

**代码示例**：

**订阅事件（在Start()中）**：
```csharp
// PlayerController告诉InputManager：跳跃时叫我！
InputManager.Instance.OnJumpPressed += Jump;
```

**触发事件（在InputManager中）**：
```csharp
// InputManager检测到按键，通知所有人
if (GetButtonDownSafe("Jump"))
{
    OnJumpPressed?.Invoke();  // 广播："有人按了跳跃！"
}
```

**接收事件（在PlayerController中）**：
```csharp
// Jump()方法被自动调用
private void Jump()
{
    // 执行跳跃逻辑
    rb.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse);
}
```

---

## 7. 玩家移动和跳跃流程

### 7.1 移动流程

```
玩家按下"A"键（向左移动）
    ↓
InputManager.Update()检测到输入
    ↓
更新 moveInput.x = -1
    ↓
PlayerController.Update()被调用
    ↓
获取移动输入：InputManager.Instance.GetMoveInput()
    ↓
计算新速度：rb.velocity = new Vector2(-1 * 8, rb.velocity.y)
    ↓
Unity物理系统根据速度移动玩家
    ↓
玩家向左移动
```

### 7.2 地面检测流程

```
PlayerController.Update()被调用
    ↓
调用 CheckGrounded()
    ↓
从玩家底部向下发射3条"射线"（左、中、右）
    ↓
检查是否碰到地面
    ↓
如果任何一条射线碰到地面 → isGrounded = true
    ↓
否则 → isGrounded = false
```

**详细说明**：

```csharp
private void CheckGrounded()
{
    // 1. 确定检测起点（玩家底部）
    Vector2 checkOrigin = playerCollider.bounds.min.y - 0.05f;
    
    // 2. 发射3条射线（左、中、右）
    RaycastHit2D[] centerHits = Physics2D.RaycastAll(
        checkOrigin,           // 起点
        Vector2.down,          // 方向（向下）
        checkDistance,         // 距离
        groundLayer            // 检测哪些层
    );
    
    // 3. 检查是否碰到地面（排除玩家自己的碰撞体）
    foreach (var hit in centerHits)
    {
        if (hit.collider != playerCollider)  // 不是自己
        {
            hitCenter = true;  // 碰到地面了！
            break;
        }
    }
    
    // 4. 如果左、中、右任意一个碰到地面，就认为在地面
    isGrounded = hitLeft || hitCenter || hitRight;
}
```

### 7.3 跳跃流程

```
玩家按下"空格"键
    ↓
InputManager检测到按键
    ↓
触发 OnJumpPressed 事件
    ↓
PlayerController的Jump()方法被调用
    ↓
检查是否可以跳跃：
    ├── 如果 requireGrounded = true
    │   └── 检查 isGrounded（是否在地面）
    │       ├── 是 → 可以跳跃
    │       └── 否 → 不能跳跃
    └── 如果 allowAirJump = true
        └── 可以跳跃（允许空中跳跃）
    ↓
如果可以跳跃：
    ├── 重置垂直速度：rb.velocity.y = 0
    └── 添加上升力：rb.AddForce(Vector2.up * jumpForce)
    ↓
Unity物理系统处理跳跃
    ↓
玩家向上移动
```

**详细代码**：

```csharp
private void Jump()
{
    // 1. 检查是否可以跳跃
    bool canJump = false;
    bool allowAirJumping = !requireGrounded && allowAirJump;
    
    if (allowAirJumping)
    {
        canJump = true;  // 允许空中跳跃
    }
    else
    {
        canJump = isGrounded;  // 必须在地面
    }
    
    // 2. 执行跳跃
    if (canJump)
    {
        if (isGrounded && rb.velocity.y <= 0.1f)
        {
            // 重置速度，添加上升力
            rb.velocity = new Vector2(rb.velocity.x, 0f);
            rb.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse);
        }
    }
}
```

---

## 8. 完整流程图

### 8.1 游戏启动完整流程

```
┌─────────────────────────────────────────┐
│  1. Unity加载场景文件                    │
│     (test_sence.scene)                  │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  2. 创建所有GameObject                   │
│     - Main Camera                        │
│     - Player                             │
│     - Ground                             │
│     - Managers (GameManager, etc.)       │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  3. 给每个GameObject添加组件             │
│     - Player → PlayerController          │
│     - Player → Rigidbody2D              │
│     - GameManager → GameManager          │
│     - InputManager → InputManager        │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  4. 调用所有 Awake()                    │
│     - GameManager.Awake()                │
│       └── Singleton.Awake()              │
│           └── 确保只有一个实例           │
│     - InputManager.Awake()               │
│     - PlayerController.Awake()           │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  5. 调用所有 Start()                    │
│     - PlayerController.Start()           │
│       └── 订阅跳跃事件                   │
│       └── InputManager.OnJumpPressed    │
│           += Jump                        │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  6. 开始游戏循环（每帧）                │
│     ┌──────────────────────────────┐   │
│     │  InputManager.Update()        │   │
│     │  └── 检查键盘输入             │   │
│     │  └── 更新 moveInput           │   │
│     │  └── 如果按跳跃 → 触发事件    │   │
│     └──────────────────────────────┘   │
│     ┌──────────────────────────────┐   │
│     │  PlayerController.Update()    │   │
│     │  └── CheckGrounded()          │   │
│     │  └── 获取移动输入             │   │
│     │  └── 更新速度                │   │
│     └──────────────────────────────┘   │
│     ┌──────────────────────────────┐   │
│     │  Unity物理系统                │   │
│     │  └── 根据速度移动对象         │   │
│     │  └── 检测碰撞                │   │
│     └──────────────────────────────┘   │
│     ┌──────────────────────────────┐   │
│     │  Unity渲染系统               │   │
│     │  └── 绘制画面                │   │
│     └──────────────────────────────┘   │
│     └── 等待下一帧（约0.016秒）    │   │
│     └── 重复上述过程                │   │
└─────────────────────────────────────────┘
```

### 8.2 玩家移动的完整流程

```
┌─────────────────────────────────────────┐
│  玩家按下"A"键                          │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  InputManager.Update()                  │
│  └── HandleInput()                      │
│      └── GetAxisRawSafe("Horizontal")   │
│      └── moveInput.x = -1                │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  PlayerController.Update()              │
│  └── GetMoveInput()                     │
│      └── 返回 moveInput = (-1, 0)       │
│  └── 计算新速度                         │
│      └── rb.velocity.x = -1 * 8 = -8    │
│      └── rb.velocity.y = 保持原值       │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  Unity物理系统                           │
│  └── 根据速度移动Player                 │
│      └── 每秒向左移动8个单位            │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  玩家向左移动                            │
└─────────────────────────────────────────┘
```

### 8.3 玩家跳跃的完整流程

```
┌─────────────────────────────────────────┐
│  玩家按下"空格"键                       │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  InputManager.Update()                  │
│  └── GetButtonDownSafe("Jump") = true   │
│  └── OnJumpPressed?.Invoke()            │
│      └── 触发事件（广播）               │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  PlayerController.Jump()                 │
│  └── 检查是否可以跳跃                   │
│      ├── requireGrounded = true?        │
│      │   └── 是 → 检查 isGrounded       │
│      │       ├── 是 → canJump = true    │
│      │       └── 否 → canJump = false   │
│      └── allowAirJump = true?           │
│          └── 是 → canJump = true         │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  如果可以跳跃：                          │
│  └── rb.velocity.y = 0                  │
│  └── rb.AddForce(Vector2.up * 8)        │
│      └── 添加上升力（8个单位）          │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  Unity物理系统                           │
│  └── 根据力移动Player                   │
│      └── 玩家向上移动                   │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  玩家跳跃                                │
└─────────────────────────────────────────┘
```

---

## 9. 关键概念总结

### 9.1 Singleton（单例模式）

**作用**：确保整个游戏只有一个管理器实例。

**实现**：
```csharp
public class InputManager : Singleton<InputManager>
{
    // 通过 InputManager.Instance 访问
}
```

**使用**：
```csharp
// 在任何地方都可以这样访问
InputManager.Instance.GetMoveInput();
```

### 9.2 事件系统（Event System）

**作用**：让对象之间可以"通信"，而不需要直接引用。

**订阅事件**：
```csharp
InputManager.Instance.OnJumpPressed += Jump;
```

**触发事件**：
```csharp
OnJumpPressed?.Invoke();
```

**取消订阅**：
```csharp
InputManager.Instance.OnJumpPressed -= Jump;
```

### 9.3 物理系统（Physics）

**Rigidbody2D**：
- 让物体受重力影响
- 让物体可以移动
- 让物体可以碰撞

**Collider2D**：
- 定义物体的"形状"
- 用于碰撞检测

**速度（Velocity）**：
- `rb.velocity.x`：水平速度（左右）
- `rb.velocity.y`：垂直速度（上下）

**力（Force）**：
- `AddForce()`：给物体施加力
- `ForceMode2D.Impulse`：瞬间力（用于跳跃）

---

## 10. 常见问题

### Q1: 为什么需要InputManager，不能直接用Input吗？

**A**: 可以，但使用InputManager的好处：
- 统一管理所有输入
- 可以轻松切换输入方式（键盘/手柄）
- 可以添加输入过滤和死区
- 其他系统只需要找InputManager，不需要知道具体输入方式

### Q2: 为什么需要事件系统？

**A**: 事件系统让代码更"解耦"：
- PlayerController不需要直接引用InputManager
- 可以轻松添加多个"监听者"（比如UI、音效）
- 修改输入逻辑时，不需要修改PlayerController

### Q3: Update()每秒调用多少次？

**A**: 通常60次（60 FPS），但取决于：
- 电脑性能
- 游戏复杂度
- 可以在Unity中设置目标帧率

### Q4: 为什么地面检测要用3条射线？

**A**: 提高检测可靠性：
- 如果只用1条，玩家站在边缘可能检测不到
- 用3条（左、中、右）可以覆盖玩家底部
- 只要任意一条碰到地面，就认为在地面

---

## 11. 下一步学习

1. **理解物理系统**：学习Rigidbody2D的更多用法
2. **学习状态机**：了解如何管理玩家的不同状态（站立、跳跃、攻击等）
3. **学习对象池**：了解如何高效地创建和销毁对象
4. **学习事件系统**：了解如何设计更复杂的事件系统

---

## 📝 总结

整个游戏的执行流程可以概括为：

1. **启动**：Unity加载场景 → 创建对象 → 初始化
2. **运行**：每帧检查输入 → 更新游戏逻辑 → 物理系统更新 → 渲染画面
3. **输入**：玩家按键 → InputManager处理 → 触发事件 → PlayerController响应
4. **移动**：更新速度 → 物理系统移动 → 玩家移动
5. **跳跃**：检测地面 → 检查条件 → 施加力 → 玩家跳跃

希望这个文档能帮助你理解整个项目的运行机制！如果还有疑问，可以查看其他教程文档。

