# 项目工程化指南

## 概述

本文档提供将项目提升到工程化水平的全面指南，包括代码质量、测试、自动化、文档、协作等方面的最佳实践。

**最后更新时间：** 2024年

---

## 目录

1. [代码质量与规范](#1-代码质量与规范)
2. [测试体系](#2-测试体系)
3. [自动化构建与CI/CD](#3-自动化构建与cicd)
4. [代码审查流程](#4-代码审查流程)
5. [依赖管理](#5-依赖管理)
6. [错误处理与日志](#6-错误处理与日志)
7. [性能监控与优化](#7-性能监控与优化)
8. [文档体系](#8-文档体系)
9. [版本控制最佳实践](#9-版本控制最佳实践)
10. [项目管理工具](#10-项目管理工具)

---

## 1. 代码质量与规范

### 1.1 代码规范

#### 当前状态
- ✅ 已有命名空间规范
- ✅ 已有接口实现规范
- ✅ 已有目录结构规范

#### 改进建议

**1. 统一代码风格**
```csharp
// 建议使用 .editorconfig 文件统一代码风格
// 创建 .editorconfig 文件在项目根目录
```

**2. 代码格式化工具**
- 使用 Unity 的代码格式化功能
- 或使用 Visual Studio / Rider 的自动格式化
- 提交代码前统一格式化

**3. 命名规范检查清单**
- [ ] 类名：PascalCase（如 `PlayerController`）
- [ ] 方法名：PascalCase（如 `GetHealth()`）
- [ ] 私有字段：camelCase 或 _camelCase（如 `private float _health`）
- [ ] 常量：UPPER_CASE（如 `MAX_HEALTH`）
- [ ] 接口：I 前缀（如 `IHealth`）
- [ ] 事件：On 前缀（如 `OnHealthChanged`）

**4. 代码复杂度控制**
- 单个方法不超过 50 行
- 单个类不超过 500 行
- 圈复杂度不超过 10

### 1.2 静态代码分析

**工具推荐：**
- Unity Code Analysis（内置）
- SonarQube（可选，企业级）
- Roslyn Analyzers（C# 代码分析）

**配置步骤：**
1. 在项目中添加 `.editorconfig` 文件
2. 配置代码分析规则
3. 在 CI/CD 中集成代码分析

---

## 2. 测试体系

### 2.1 单元测试

**当前状态：** 未实现

**实施步骤：**

**1. 创建测试目录结构**
```
Assets/
├── Tests/
│   ├── EditMode/          # 编辑器模式测试
│   │   ├── Core/
│   │   ├── Frameworks/
│   │   └── Managers/
│   └── PlayMode/          # 运行时测试
│       ├── Core/
│       └── Gameplay/
```

**2. 安装测试框架**
- Unity Test Framework（Unity 内置）
- 在 Package Manager 中安装

**3. 编写测试示例**

```csharp
// Tests/EditMode/Core/Managers/InputManagerTests.cs
using NUnit.Framework;
using UnityEngine;
using Core.Managers;

namespace Tests.EditMode.Core.Managers
{
    public class InputManagerTests
    {
        [Test]
        public void GetMoveInput_ReturnsZero_WhenNoInput()
        {
            // Arrange
            var inputManager = new GameObject().AddComponent<InputManager>();
            
            // Act
            var result = inputManager.GetMoveInput();
            
            // Assert
            Assert.AreEqual(Vector2.zero, result);
        }
    }
}
```

**4. 测试覆盖率目标**
- 核心系统（0_Core）：80%+
- 游戏玩法（1_Gameplay）：60%+
- 工具类：90%+

### 2.2 集成测试

**用途：** 测试多个系统协同工作

**示例：**
```csharp
// Tests/PlayMode/Integration/BossBattleIntegrationTests.cs
[UnityTest]
public IEnumerator BossBattle_StartsCorrectly()
{
    // 测试 Boss 战斗系统完整流程
    yield return new WaitForSeconds(1f);
    // 验证结果
}
```

### 2.3 性能测试

**工具：**
- Unity Profiler
- Unity Test Framework Performance Tests

**测试内容：**
- 帧率稳定性
- 内存使用
- 加载时间
- 物理性能

---

## 3. 自动化构建与CI/CD

### 3.1 持续集成（CI）

**推荐平台：**
- GitHub Actions（推荐，与 GitHub 集成）
- Jenkins（自托管）
- GitLab CI（如果使用 GitLab）

### 3.2 GitHub Actions 配置

**创建文件：** `.github/workflows/unity-build.yml`

```yaml
name: Unity Build

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
      with:
        lfs: true
    
    - name: Setup Unity
      uses: game-ci/unity-setup@v1
      with:
        unity-version: 2021.3.0f1
    
    - name: Run Tests
      uses: game-ci/unity-test-runner@v1
      with:
        testMode: all
    
    - name: Build
      uses: game-ci/unity-builder@v1
      with:
        targetPlatform: StandaloneWindows64
```

### 3.3 构建自动化

**构建脚本：**
```csharp
// Assets/Editor/BuildScript.cs
using UnityEditor;
using UnityEngine;

public class BuildScript
{
    [MenuItem("Build/Build Windows")]
    public static void BuildWindows()
    {
        BuildPlayerOptions buildPlayerOptions = new BuildPlayerOptions();
        buildPlayerOptions.scenes = GetScenes();
        buildPlayerOptions.locationPathName = "Builds/Windows/Game.exe";
        buildPlayerOptions.target = BuildTarget.StandaloneWindows64;
        buildPlayerOptions.options = BuildOptions.None;
        
        BuildPipeline.BuildPlayer(buildPlayerOptions);
    }
    
    private static string[] GetScenes()
    {
        // 获取所有场景
        return EditorBuildSettings.scenes
            .Where(s => s.enabled)
            .Select(s => s.path)
            .ToArray();
    }
}
```

---

## 4. 代码审查流程

### 4.1 Pull Request 流程

**工作流程：**
1. 创建功能分支：`feature/xxx` 或 `fix/xxx`
2. 开发并提交代码
3. 创建 Pull Request
4. 代码审查
5. 通过后合并到主分支

### 4.2 代码审查检查清单

**功能检查：**
- [ ] 功能按需求实现
- [ ] 没有引入新 Bug
- [ ] 边界情况已处理

**代码质量：**
- [ ] 遵循代码规范
- [ ] 命名清晰易懂
- [ ] 没有重复代码
- [ ] 注释充分

**架构检查：**
- [ ] 符合项目架构
- [ ] 没有过度耦合
- [ ] 接口使用正确

**测试：**
- [ ] 有单元测试
- [ ] 测试通过
- [ ] 手动测试完成

### 4.3 审查工具

- GitHub Pull Requests（内置）
- Reviewable（第三方，更强大）

---

## 5. 依赖管理

### 5.1 Unity Package Manager

**当前状态：** 需要规范化

**改进建议：**

**1. 使用 manifest.json 管理依赖**
```json
{
  "dependencies": {
    "com.unity.test-framework": "1.1.33",
    "com.unity.textmeshpro": "3.0.6"
  }
}
```

**2. 版本锁定**
- 明确指定包版本
- 避免使用 `latest` 标签

**3. 依赖文档化**
- 在 `README.md` 中记录所有依赖
- 说明每个依赖的用途

### 5.2 第三方库管理

**原则：**
- 优先使用 Unity Package Manager
- 避免直接修改第三方代码
- 如需修改，创建包装类

---

## 6. 错误处理与日志

### 6.1 统一错误处理

**当前状态：** 部分实现（有 Debug.Log）

**改进建议：**

**1. 创建日志系统**
```csharp
// Scenes/0_Core/Utilities/Logging/Logger.cs
namespace Core.Utilities.Logging
{
    public enum LogLevel
    {
        Debug,
        Info,
        Warning,
        Error,
        Fatal
    }
    
    public static class Logger
    {
        public static void Log(LogLevel level, string message, object context = null)
        {
            // 统一日志处理
            // 可以添加文件日志、远程日志等
        }
    }
}
```

**2. 异常处理规范**
```csharp
// ✅ 好的做法
try
{
    // 可能失败的操作
}
catch (SpecificException ex)
{
    Logger.Log(LogLevel.Error, $"操作失败: {ex.Message}", this);
    // 处理错误
}

// ❌ 避免
catch (Exception ex)
{
    // 捕获所有异常但不处理
}
```

### 6.2 错误报告

**建议实现：**
- 崩溃报告收集（如 Sentry）
- 错误统计和分析
- 用户反馈机制

---

## 7. 性能监控与优化

### 7.1 性能指标

**关键指标：**
- FPS（目标：60 FPS）
- 内存使用
- 加载时间
- Draw Calls
- 物理计算时间

### 7.2 性能监控工具

**Unity 内置：**
- Profiler
- Frame Debugger
- Memory Profiler

**第三方：**
- Unity Performance Testing Extension
- UPR (Unity Performance Reporting)

### 7.3 性能优化检查清单

**代码优化：**
- [ ] 避免在 Update 中分配内存
- [ ] 使用对象池
- [ ] 合理使用缓存
- [ ] 避免不必要的计算

**资源优化：**
- [ ] 纹理压缩
- [ ] 音频压缩
- [ ] 模型优化
- [ ] 图集打包

---

## 8. 文档体系

### 8.1 当前文档状态

**已有：**
- ✅ 教程文档
- ✅ 设计文档
- ✅ 开发规范
- ✅ 问题排查

**需要补充：**

### 8.2 API 文档

**工具：**
- XML 文档注释（C# 内置）
- DocFX（生成 HTML 文档）

**示例：**
```csharp
/// <summary>
/// 获取玩家当前生命值
/// </summary>
/// <param name="playerId">玩家ID</param>
/// <returns>当前生命值，如果玩家不存在返回 -1</returns>
/// <exception cref="ArgumentException">当 playerId 无效时抛出</exception>
public float GetPlayerHealth(int playerId)
{
    // 实现
}
```

### 8.3 架构文档

**建议创建：**
- `架构设计.md` - 系统架构图
- `数据流图.md` - 数据流向
- `类图.md` - 主要类关系

### 8.4 变更日志

**创建：** `CHANGELOG.md`

```markdown
# 变更日志

## [1.0.0] - 2024-XX-XX

### 新增
- Boss 战斗系统
- 存档系统

### 修复
- 修复跳跃问题
- 修复接口实现问题

### 改进
- 优化性能
- 改进代码结构
```

---

## 9. 版本控制最佳实践

### 9.1 Git 工作流

**推荐：** Git Flow

```
main (生产环境)
  └── develop (开发分支)
      ├── feature/xxx (功能分支)
      ├── fix/xxx (修复分支)
      └── release/xxx (发布分支)
```

### 9.2 提交信息规范

**格式：**
```
<type>(<scope>): <subject>

<body>

<footer>
```

**类型：**
- `feat`: 新功能
- `fix`: 修复 Bug
- `docs`: 文档更新
- `style`: 代码格式
- `refactor`: 重构
- `test`: 测试
- `chore`: 构建/工具

**示例：**
```
feat(boss): 添加 Boss 战斗系统

实现了 Boss 的基础行为、状态管理和阶段切换功能

Closes #123
```

### 9.3 .gitignore 优化

**确保包含：**
```
# Unity
[Ll]ibrary/
[Tt]emp/
[Oo]bj/
[Bb]uild/
*.csproj
*.unityproj
*.sln

# Visual Studio
.vs/
*.user
*.suo

# 日志
*.log
```

---

## 10. 项目管理工具

### 10.1 任务管理

**推荐工具：**
- GitHub Issues（与代码集成）
- GitHub Projects（看板）
- Trello（简单易用）
- Jira（企业级）

### 10.2 Issue 模板

**创建：** `.github/ISSUE_TEMPLATE/bug_report.md`

```markdown
---
name: Bug 报告
about: 报告一个 Bug
title: '[BUG] '
labels: bug
---

## 描述
简要描述 Bug

## 重现步骤
1. 执行 '...'
2. 点击 '...'
3. 看到错误

## 预期行为
应该发生什么

## 实际行为
实际发生了什么

## 环境
- Unity 版本: 
- 操作系统: 
- 其他信息:
```

### 10.3 里程碑管理

**建议：**
- 使用 GitHub Milestones
- 定期回顾和调整
- 明确发布计划

---

## 实施优先级

### 第一阶段（立即实施）
1. ✅ 代码规范统一（.editorconfig）
2. ✅ 提交信息规范
3. ✅ Issue 模板
4. ✅ 变更日志

### 第二阶段（1-2周内）
1. 单元测试框架搭建
2. 日志系统
3. 代码审查流程
4. API 文档生成

### 第三阶段（1个月内）
1. CI/CD 配置
2. 性能监控
3. 自动化测试
4. 架构文档

### 第四阶段（持续改进）
1. 测试覆盖率提升
2. 性能优化
3. 工具链完善
4. 团队协作优化

---

## 工具推荐清单

### 开发工具
- **IDE**: Visual Studio / Rider
- **版本控制**: Git + GitHub
- **代码审查**: GitHub Pull Requests

### 测试工具
- **单元测试**: Unity Test Framework
- **性能测试**: Unity Profiler
- **集成测试**: Unity Test Framework

### 构建工具
- **CI/CD**: GitHub Actions
- **构建脚本**: Unity Editor Scripts

### 文档工具
- **API 文档**: DocFX / XML Comments
- **架构图**: Draw.io / PlantUML
- **文档**: Markdown

### 项目管理
- **任务管理**: GitHub Issues
- **看板**: GitHub Projects
- **协作**: GitHub Discussions

---

## 检查清单

### 代码质量
- [ ] 代码规范统一
- [ ] 静态代码分析配置
- [ ] 代码审查流程建立
- [ ] 代码格式化自动化

### 测试
- [ ] 单元测试框架搭建
- [ ] 核心系统测试覆盖
- [ ] 集成测试实现
- [ ] 性能测试建立

### 自动化
- [ ] CI/CD 配置
- [ ] 自动化构建
- [ ] 自动化测试
- [ ] 自动化部署

### 文档
- [ ] API 文档生成
- [ ] 架构文档完善
- [ ] 变更日志维护
- [ ] 开发指南更新

### 协作
- [ ] Git 工作流建立
- [ ] Issue 模板创建
- [ ] Pull Request 流程
- [ ] 代码审查检查清单

---

## 相关文档

- [接口实现与类型匹配规范](./接口实现与类型匹配规范.md)
- [命名空间冲突问题-Camera类型](./命名空间冲突问题-Camera类型.md)
- [目录注解](../设计文档/目录注解.md)

---

## 更新记录

- 2024-XX-XX：初始版本，创建项目工程化指南

---

**维护者：** 开发团队  
**最后更新：** 2024年
