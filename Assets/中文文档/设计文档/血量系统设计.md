# 血量系统设计文档

> **设计阶段：** 概念设计  
> **相关系统：** Boss战斗系统、玩家系统、伤害系统  
> **创建时间：** 2024年

---

## 📋 目录

1. [需求分析](#需求分析)
2. [设计目标](#设计目标)
3. [核心概念](#核心概念)
4. [数值系统设计](#数值系统设计)
5. [UI显示系统设计](#ui显示系统设计)
6. [系统架构设计](#系统架构设计)
7. [接口设计](#接口设计)
8. [数据结构设计](#数据结构设计)
9. [与其他系统的集成](#与其他系统的集成)
10. [扩展性考虑](#扩展性考虑)
11. [待讨论的问题](#待讨论的问题)

---

## 需求分析

### 1.1 功能需求

**基础需求：**
- ✅ 对象有生命值（HP）和最大生命值（MaxHP）
- ✅ 可以受到伤害（TakeDamage）
- ✅ 可以恢复生命值（Heal）
- ✅ 生命值为0时死亡
- ✅ 死亡后触发死亡事件

**进阶需求：**
- ✅ 无敌时间（Invincibility） - 受伤后短暂无敌，避免连续受伤
- ✅ 生命值变化事件 - 通知其他系统（UI更新、音效等）
- ✅ 死亡延迟 - 死亡后可能有动画，延迟销毁
- ✅ 生命值上限变化 - 可能通过道具/技能改变最大生命值

**Boss特殊需求：**
- ✅ 阶段转换 - 生命值达到阈值时切换阶段
- ✅ 护盾/护甲 - 可能有多层防护
- ✅ 生命值百分比事件 - 用于触发特殊行为

**玩家特殊需求：**
- ✅ 生命值保存 - 需要保存到存档系统
- ✅ 生命值UI显示 - 实时更新UI
- ✅ 死亡处理 - 游戏结束或重生

---

## 设计目标

### 2.1 设计原则

1. **通用性** - 血量系统应该适用于玩家、Boss、敌人、NPC等所有需要生命值的对象
2. **解耦** - 血量系统应该独立，不依赖具体的游戏对象类型
3. **可扩展** - 易于添加新功能（护盾、护甲、生命值上限变化等）
4. **事件驱动** - 通过事件系统通知其他系统，而不是直接耦合
5. **易用性** - API简单明了，易于使用

### 2.2 设计约束

- 必须与现有的事件系统（EventSystem）集成
- 必须与存档系统（SaveSystem）兼容
- 必须支持Unity的组件系统（MonoBehaviour）
- 必须考虑性能（避免每帧大量计算）

---

## 核心概念

### 3.1 生命值（Health）

**定义：** 对象当前的生命值，范围通常是 [0, MaxHealth]

**特性：**
- 不能超过最大生命值
- 不能小于0
- 为0时对象死亡

### 3.2 最大生命值（MaxHealth）

**定义：** 对象生命值的上限

**特性：**
- 可以动态改变（通过道具、技能等）
- 改变时，当前生命值按比例调整（可选）
- 最小值为1

### 3.3 无敌时间（Invincibility）

**定义：** 受伤后的一段时间内，不会再次受到伤害

**特性：**
- 有持续时间（例如0.5秒）
- 可以被打断（某些攻击无视无敌）
- 可能有视觉反馈（闪烁效果）

### 3.4 死亡（Death）

**定义：** 生命值降为0时的状态

**特性：**
- 触发死亡事件
- 可能有死亡动画
- 可能有延迟销毁
- 死亡后不能再受到伤害或恢复

---

## 数值系统设计

### 4.1 玩家基础数值配置

**初始配置：**
- **初始生命值：** 6点
- **初始最大生命值：** 6点
- **最小生命值：** 0点
- **最小最大生命值：** 6点（不能低于初始值）

**数值类型：**
- 使用 `float` 类型存储生命值（支持小数，例如1.5点）
- 显示时保留1位小数（可选，根据需求决定）

**数值范围：**
- 当前生命值范围：`[0, MaxHealth]`
- 最大生命值范围：`[6, +∞)`（最小值为初始值6）

---

### 4.2 最大生命值增加机制

**增加方式（未来扩展）：**
1. **永久增加** - 通过收集道具/升级
   - 例如：收集"生命值碎片" → 最大生命值+2
2. **临时增加** - 通过技能/道具
   - 例如：使用"生命值药水" → 临时最大生命值+4（持续一段时间）
3. **装备增加** - 通过装备
   - 例如：装备"生命值护符" → 最大生命值+2

**增加规则：**
- **按比例保持当前生命值**（推荐方案）
  - 例如：6/6（100%）→ 增加2点 → 8/8（保持100%）
  - 例如：3/6（50%）→ 增加2点 → 4/8（保持50%）
  - 公式：`newCurrentHealth = (currentHealth / oldMaxHealth) * newMaxHealth`
- **同步增加当前生命值**（可选方案）
  - 例如：6/6 → 增加2点 → 8/8
  - 例如：3/6 → 增加2点 → 5/8（当前生命值也+2）

**建议：** 使用按比例保持，更符合游戏平衡，避免玩家通过增加最大生命值来"免费"恢复生命值。

---

### 4.3 生命值计算示例

**场景1：初始状态**
- 当前生命值：6点
- 最大生命值：6点
- 生命值百分比：100%

**场景2：受到伤害**
- 受到2点伤害
- 当前生命值：4点
- 最大生命值：6点
- 生命值百分比：66.7%

**场景3：最大生命值增加**
- 当前状态：4/6（66.7%）
- 增加最大生命值：+2点
- 新状态：5.33/8（保持66.7%）
- 或者：5/8（向下取整，66.7%）

**场景4：恢复生命值**
- 当前状态：4/8
- 恢复2点
- 新状态：6/8

---

## UI显示系统设计

### 5.1 心的显示规则

**基本规则：**
- **2点 = 1颗完整的心** ❤️
- **1点 = 半颗心** 💔 或 ❤️（半透明/灰色）
- **0点 = 空的心** ⬜ 或 ❤️（完全透明/灰色）

**显示逻辑示例：**

| 当前生命值 | 最大生命值 | 显示效果 |
|-----------|-----------|---------|
| 6点 | 6点 | ❤️ ❤️ ❤️ （3颗完整） |
| 5点 | 6点 | ❤️ ❤️ 💔 （2颗完整 + 1颗半心） |
| 4点 | 6点 | ❤️ ❤️ ⬜ （2颗完整 + 1颗空心） |
| 3点 | 6点 | ❤️ 💔 ⬜ （1颗完整 + 1颗半心 + 1颗空心） |
| 2点 | 6点 | ❤️ ⬜ ⬜ （1颗完整 + 2颗空心） |
| 1点 | 6点 | 💔 ⬜ ⬜ （1颗半心 + 2颗空心） |
| 0点 | 6点 | ⬜ ⬜ ⬜ （3颗空心） |

**最大生命值增加后的显示：**

| 当前生命值 | 最大生命值 | 显示效果 |
|-----------|-----------|---------|
| 8点 | 8点 | ❤️ ❤️ ❤️ ❤️ （4颗完整） |
| 7点 | 8点 | ❤️ ❤️ ❤️ 💔 （3颗完整 + 1颗半心） |
| 5点 | 8点 | ❤️ ❤️ 💔 ⬜ （2颗完整 + 1颗半心 + 1颗空心） |

---

### 5.2 心的状态枚举

```csharp
public enum HeartState
{
    Empty,   // 空（0点）
    Half,    // 半颗（1点）
    Full     // 完整（2点）
}
```

---

### 5.3 UI组件结构设计

**HealthBarUI 组件结构：**

```
HealthBarUI (MonoBehaviour)
├── heartContainer (GameObject) - 心的容器（HorizontalLayoutGroup）
│   ├── Heart_0 (GameObject) - 第1颗心
│   │   ├── Image (完整心Sprite)
│   │   └── Image (半颗心Sprite，默认隐藏)
│   ├── Heart_1 (GameObject) - 第2颗心
│   ├── Heart_2 (GameObject) - 第3颗心
│   └── ... (动态添加更多心)
│
├── heartPrefab (GameObject) - 心的预制体
│   ├── FullHeart (Image/Sprite) - 完整心的图片
│   ├── HalfHeart (Image/Sprite) - 半颗心的图片
│   └── EmptyHeart (Image/Sprite) - 空心的图片（可选，或使用透明）
│
└── 配置
    ├── heartSpacing (float) - 心之间的间距
    ├── heartSize (Vector2) - 心的大小（例如：32x32像素）
    ├── heartsPerRow (int) - 每行显示的心数（可选，0=不限制）
    └── maxHeartsToShow (int) - 最大显示心数（可选，0=显示所有）
```

---

### 5.4 UI更新算法

**计算逻辑：**

```csharp
// 伪代码
void UpdateHealthDisplay(float currentHealth, float maxHealth)
{
    // 1. 计算需要显示的心数（向上取整）
    int totalHearts = Mathf.CeilToInt(maxHealth / 2f);
    
    // 2. 确保有足够的心UI对象
    EnsureHeartObjects(totalHearts);
    
    // 3. 更新每颗心的状态
    for (int i = 0; i < totalHearts; i++)
    {
        float heartStartHealth = i * 2f;      // 这颗心开始的生命值
        float heartEndHealth = (i + 1) * 2f;  // 这颗心结束的生命值
        
        HeartState state;
        if (currentHealth >= heartEndHealth)
        {
            // 完整的心（当前生命值 >= 这颗心的结束值）
            state = HeartState.Full;
        }
        else if (currentHealth > heartStartHealth)
        {
            // 半颗心（当前生命值在这颗心的范围内）
            state = HeartState.Half;
        }
        else
        {
            // 空心（当前生命值 < 这颗心的开始值）
            state = HeartState.Empty;
        }
        
        UpdateHeartUI(i, state);
    }
}
```

**计算示例：**

- **当前生命值 = 5点，最大生命值 = 6点**
  - 需要显示：3颗心（6/2 = 3）
  - 第1颗心（0-2点）：5 >= 2 → Full ❤️
  - 第2颗心（2-4点）：5 >= 4 → Full ❤️
  - 第3颗心（4-6点）：5 > 4 且 5 < 6 → Half 💔

- **当前生命值 = 7点，最大生命值 = 8点**
  - 需要显示：4颗心（8/2 = 4）
  - 第1颗心（0-2点）：7 >= 2 → Full ❤️
  - 第2颗心（2-4点）：7 >= 4 → Full ❤️
  - 第3颗心（4-6点）：7 >= 6 → Full ❤️
  - 第4颗心（6-8点）：7 > 6 且 7 < 8 → Half 💔

---

### 5.5 UI实现方案

**方案A：使用Sprite切换（推荐）**

**优点：**
- 实现简单
- 性能好
- 易于制作美术资源
- 符合当前需求（只有3种状态）

**实现：**
- 每颗心是一个 `Image` 组件
- 根据状态切换不同的Sprite
- 3种Sprite：完整心、半颗心、空心
- 使用 `Image.sprite` 属性切换

**方案B：使用遮罩/填充**

**优点：**
- 更灵活，可以显示任意比例
- 支持平滑过渡动画

**缺点：**
- 实现较复杂
- 不符合当前需求（只需要3种状态）

**建议：** 使用方案A（Sprite切换），简单高效，完全满足需求。

---

### 5.6 UI布局设计

**水平布局（推荐，初期使用）：**

```
[❤️] [❤️] [💔] [⬜] [⬜]
```

- 从左到右排列
- 使用Unity的 `HorizontalLayoutGroup`
- 每颗心固定大小（例如：32x32像素）
- 心之间固定间距（例如：4像素）

**网格布局（最大生命值很多时）：**

```
[❤️] [❤️] [💔]
[⬜] [⬜] [⬜]
```

- 每行显示固定数量（例如：6颗心）
- 使用Unity的 `GridLayoutGroup`
- 自动换行

**建议：** 初期使用水平布局，如果最大生命值超过12点（6颗心），再考虑网格布局。

---

### 5.7 UI动画和反馈

**生命值变化动画：**

1. **受伤时：**
   - 心从完整 → 半颗/空心，有淡出动画
   - 或者：心闪烁红色
   - 持续时间：0.2-0.3秒

2. **恢复时：**
   - 心从空心 → 半颗/完整，有淡入动画
   - 或者：心闪烁绿色
   - 持续时间：0.2-0.3秒

**最大生命值增加动画：**

- 新心从右侧滑入
- 或者：新心淡入出现
- 持续时间：0.3-0.5秒

**建议：** 初期可以不做动画，先实现基础功能，后续再添加动画效果。

---

## 系统架构设计

### 6.1 组件化设计

**方案A：单一组件方案**
```
HealthComponent (MonoBehaviour)
├── 管理所有生命值相关功能
├── 处理伤害、治疗、死亡
└── 触发事件
```

**优点：**
- 简单直接
- 易于理解
- 适合小型项目

**缺点：**
- 功能集中，可能变得臃肿
- 扩展性较差

---

**方案B：接口 + 组件方案（推荐）**
```
IDamageable (接口)
├── TakeDamage()
├── Heal()
└── IsAlive()

HealthComponent (MonoBehaviour)
├── 实现 IDamageable
├── 管理生命值数据
├── 处理伤害逻辑
└── 触发事件
```

**优点：**
- 解耦，其他系统只需要知道IDamageable接口
- 易于测试
- 易于扩展（可以有不同的实现）

**缺点：**
- 稍微复杂一些

---

### 6.2 事件系统集成

**事件类型：**

1. **HealthChangedEvent** - 生命值变化时触发
   - 当前生命值
   - 最大生命值
   - 变化量（正数=恢复，负数=伤害）

2. **HealthDepletedEvent** - 生命值降为0时触发
   - 对象引用
   - 死亡原因（可选）

3. **MaxHealthChangedEvent** - 最大生命值变化时触发
   - 新的最大生命值
   - 旧的最大生命值

4. **InvincibilityStartedEvent** - 开始无敌时触发
5. **InvincibilityEndedEvent** - 无敌结束时触发

---

## 接口设计

### 7.1 IDamageable 接口

```csharp
public interface IDamageable
{
    // 基础属性
    float CurrentHealth { get; }
    float MaxHealth { get; }
    bool IsAlive { get; }
    bool IsInvincible { get; }
    
    // 核心方法
    void TakeDamage(float damage, GameObject damageSource = null);
    void Heal(float amount);
    void SetMaxHealth(float newMaxHealth, bool adjustCurrent = true);
    
    // 事件
    event Action<float, float> OnHealthChanged;  // (current, max)
    event Action OnDeath;
}
```

**设计问题：**
- ❓ 是否需要在接口中包含事件？还是只通过EventSystem？
- ❓ TakeDamage的参数应该是什么？只有伤害值，还是包含伤害信息（DamageInfo）？

---

### 7.2 HealthComponent 设计

**基础属性：**
- `currentHealth` - 当前生命值
- `maxHealth` - 最大生命值
- `invincibilityDuration` - 无敌时间（秒）
- `isInvincible` - 是否无敌

**方法：**
- `TakeDamage(float damage)` - 受到伤害
- `Heal(float amount)` - 恢复生命值
- `SetMaxHealth(float newMaxHealth)` - 设置最大生命值
- `SetInvincible(bool invincible)` - 手动设置无敌状态
- `Kill()` - 直接杀死（用于特殊场景）

**设计问题：**
- ❓ 是否应该支持"临时生命值"（超过最大生命值的额外生命值）？
- ❓ 是否应该支持"护盾"系统（额外的生命值层）？

---

## 数据结构设计

### 8.1 伤害信息（DamageInfo）

**问题：** 伤害系统应该传递什么信息？

**方案A：简单数值**
```csharp
TakeDamage(float damage)
```

**方案B：伤害信息结构**
```csharp
public struct DamageInfo
{
    public float amount;           // 伤害值
    public GameObject source;      // 伤害来源
    public DamageType type;         // 伤害类型（物理/魔法/真实伤害等）
    public bool ignoreInvincibility; // 是否无视无敌
    public Vector2 knockbackForce;  // 击退力（可选）
}
```

**讨论点：**
- 现在是否需要这么复杂？还是先简单，后续扩展？
- 如果先简单，后续如何扩展而不破坏现有代码？

---

### 8.2 生命值变化信息

**问题：** 事件中应该传递什么信息？

**方案A：简单数值**
```csharp
OnHealthChanged(float currentHealth, float maxHealth)
```

**方案B：详细信息**
```csharp
public struct HealthChangeInfo
{
    public float previousHealth;
    public float currentHealth;
    public float maxHealth;
    public float changeAmount;  // 正数=恢复，负数=伤害
    public bool isDead;
}
```

---

## 与其他系统的集成

### 9.1 与事件系统集成

**设计问题：**
- ❓ HealthComponent应该直接触发EventManager的事件，还是通过接口事件？
- ❓ 是否需要两种方式都支持？

**建议方案：**
- HealthComponent内部使用C#事件（OnHealthChanged等）
- 同时触发EventManager的GameEvent（用于系统间通信）
- 这样既灵活又解耦

---

### 9.2 与存档系统集成

**设计问题：**
- ❓ 玩家的生命值如何保存？
- ❓ 是否所有有HealthComponent的对象都需要保存？

**建议：**
- 只有玩家的生命值需要保存
- 通过标记或接口区分（例如 `ISaveable`）
- 或者HealthComponent有 `shouldSave` 标志

---

### 9.3 与UI系统集成

**UI获取生命值信息：**
- UI通过事件系统监听生命值变化事件
- 或者通过引用HealthComponent直接读取
- 创建 `HealthBarUI` 组件，可以绑定到任何HealthComponent

**HealthBarUI组件职责：**
- 监听 `HealthChangedEvent` 事件
- 根据当前生命值和最大生命值更新心的显示
- 动态创建/销毁心UI对象（当最大生命值变化时）
- 处理心的状态切换（完整/半颗/空心）

**UI更新流程：**
1. HealthComponent触发 `HealthChangedEvent`
2. HealthBarUI监听到事件
3. 调用 `UpdateHealthDisplay(currentHealth, maxHealth)`
4. 计算需要显示的心数和每颗心的状态
5. 更新UI显示

---

### 9.4 与Boss系统集成

**设计问题：**
- ❓ Boss的生命值百分比如何用于阶段转换？
- ❓ 是否需要在HealthComponent中内置阶段转换逻辑？

**建议：**
- HealthComponent只负责生命值管理
- BossController监听生命值变化事件，自己处理阶段转换
- 或者创建 `BossHealthComponent` 继承 `HealthComponent`，添加阶段转换功能

---

## 扩展性考虑

### 10.1 未来可能的功能

1. **护盾系统**
   - 额外的生命值层
   - 可能需要在HealthComponent中添加护盾相关功能
   - 或者创建独立的 `ShieldComponent`

2. **护甲系统**
   - 减少受到的伤害
   - 可能需要在TakeDamage时计算护甲减免
   - 或者创建独立的 `ArmorComponent`

3. **生命值上限变化**
   - 通过道具/技能临时或永久改变最大生命值
   - HealthComponent需要支持这个功能

4. **生命值恢复**
   - 持续恢复（每帧恢复）
   - 延迟恢复（受伤后一段时间开始恢复）
   - 可能需要独立的恢复系统

5. **伤害类型**
   - 物理伤害、魔法伤害、真实伤害等
   - 不同类型的伤害可能有不同的处理方式

---

### 10.2 设计模式考虑

**观察者模式：**
- HealthComponent作为被观察者
- UI、Boss系统、存档系统等作为观察者
- 通过事件系统实现

**策略模式：**
- 不同的伤害计算策略（普通伤害、护甲减免、护盾吸收等）
- 可以在HealthComponent中配置策略

**装饰器模式：**
- 如果需要给HealthComponent添加额外功能（护盾、护甲）
- 可以通过组合的方式实现

---

## 待讨论的问题

### 11.1 核心设计问题

1. **伤害信息结构**
   - ❓ 现在是否需要DamageInfo结构，还是先简单传递float？
   - ❓ 如果先简单，后续如何扩展？

2. **接口设计**
   - ❓ IDamageable接口应该包含哪些方法？
   - ❓ 是否需要在接口中包含事件？

3. **无敌时间**
   - ❓ 无敌时间应该由HealthComponent管理，还是由外部系统管理？
   - ❓ 是否所有伤害都应该受无敌时间影响？

4. **生命值上限变化**
   - ❓ 改变最大生命值时，当前生命值如何调整？
   - ❓ 按比例调整，还是保持绝对值？

### 11.2 集成问题

5. **事件系统**
   - ❓ HealthComponent应该触发哪些事件？
   - ❓ 是否同时支持C#事件和EventManager事件？

6. **存档系统**
   - ❓ 哪些对象的生命值需要保存？
   - ❓ 如何区分需要保存的对象？

7. **Boss系统**
   - ❓ Boss的阶段转换逻辑应该放在哪里？
   - ❓ HealthComponent中，还是BossController中？

### 11.3 扩展性问题

8. **护盾和护甲**
   - ❓ 现在是否需要考虑护盾和护甲？
   - ❓ 如果需要，如何设计才能不破坏现有系统？

9. **伤害类型**
   - ❓ 现在是否需要支持不同的伤害类型？
   - ❓ 如果不需要，如何设计才能后续容易添加？

---

## 设计建议总结

### 推荐方案

1. **接口 + 组件**
   - 使用 `IDamageable` 接口
   - `HealthComponent` 实现接口
   - 其他系统只需要知道接口

2. **事件驱动**
   - HealthComponent触发C#事件（用于组件间通信）
   - 同时触发EventManager事件（用于系统间通信）

3. **先简单，后扩展**
   - 先实现基础功能（生命值、伤害、治疗、死亡）
   - 使用简单参数（float damage）
   - 但设计时考虑扩展性（可以后续改为DamageInfo）

4. **职责分离**
   - HealthComponent只负责生命值管理
   - 阶段转换、UI更新等由其他系统负责
   - 通过事件系统通信

5. **数值系统**
   - 初始生命值：6点
   - 最大生命值可增加，增加时按比例保持当前生命值
   - 使用float类型，支持小数（可选）

6. **UI显示系统**
   - 2点 = 1颗完整心
   - 1点 = 半颗心
   - 0点 = 空心
   - 使用Sprite切换实现
   - 水平布局，动态创建心UI对象

---

## 已确定的设计决策

### ✅ 数值系统
- **初始生命值：** 6点
- **初始最大生命值：** 6点
- **最大生命值增加规则：** 按比例保持当前生命值
- **数值类型：** float（支持小数）

### ✅ UI显示系统
- **显示规则：** 2点=1颗心，1点=半颗心，0点=空心
- **实现方式：** Sprite切换（3种状态）
- **布局方式：** 水平布局（初期）
- **更新方式：** 通过事件系统监听生命值变化

### ⏳ 待确定的设计问题

1. **伤害信息** - 现在用简单的float，还是用DamageInfo结构？
2. **事件系统** - 需要触发哪些事件？如何触发？
3. **无敌时间** - 如何实现？由谁管理？
4. **Boss阶段转换** - 逻辑放在哪里？

---

**设计文档已更新，包含具体的数值系统和UI显示方案！** ✅

